<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redis 缓存穿透、击穿与雪崩问题的解决方案 - YOUNG的个人博客</title>
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/tech-blog.css">
    <link rel="stylesheet" href="../css/blog-post.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
</head>
<body>
    <header>
        <div class="container">
            <nav>
                <div class="logo">YOUNG</div>
                <ul class="nav-links">
                    <li><a href="../index.html">首页</a></li>
                    <li><a href="../index.html#about">关于我</a></li>
                    <li><a href="../index.html#projects">项目经历</a></li>
                    <li><a href="../tech-blog.html" class="active">技术分享</a></li>
                    <li><a href="../index.html#gallery">生活相册</a></li>
                    <li><a href="../index.html#contact">联系我</a></li>
                </ul>
                <div class="hamburger">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </nav>
        </div>
    </header>

    <main class="blog-post-container">
        <div class="container">
            <article class="blog-post">
                <div class="post-header">
                    <h1 class="post-title">Redis 缓存穿透、击穿与雪崩问题的解决方案</h1>
                    <div class="post-meta">
                        <span class="post-date"><i class="far fa-calendar-alt"></i> 2023-09-22</span>
                        <span class="post-author"><i class="far fa-user"></i> YOUNG</span>
                        <span class="post-read-time"><i class="far fa-clock"></i> 8 分钟阅读</span>
                    </div>
                    <div class="post-tags">
                        <a href="../tech-blog.html" class="post-tag">Redis</a>
                        <a href="../tech-blog.html" class="post-tag">缓存</a>
                        <a href="../tech-blog.html" class="post-tag">高并发</a>
                    </div>
                </div>
                
                <div class="post-featured-image">
                    <img src="../images/blog/redis.jpg" alt="Redis 缓存文章配图">
                </div>
                
                <div class="post-content">
                    <h2>前言</h2>
                    <p>在高并发系统中，Redis 作为缓存中间件发挥着至关重要的作用，它能够显著提升系统性能、降低数据库负载。然而，在实际应用中，我们常常会遇到缓存穿透、缓存击穿和缓存雪崩这三类问题，如果不加以妥善处理，轻则影响用户体验，重则引发系统崩溃。</p>
                    <p>本文将深入探讨这三类问题的成因、危害和解决方案，并结合实际业务场景提供相应的代码示例。</p>
                    
                    <h2>1. 缓存穿透</h2>
                    <h3>1.1 问题描述</h3>
                    <p>缓存穿透是指查询一个不存在的数据，因为缓存中没有，会直接查询数据库，若请求量大，且多为不存在的数据查询，则会给数据库带来巨大压力，甚至可能导致数据库崩溃。</p>
                    <div class="code-block">
                        <pre><code class="language-java">
public Object getDataById(String id) {
    // 从缓存中获取数据
    Object cacheData = redisTemplate.opsForValue().get(id);
    
    // 缓存为空，查询数据库
    if (cacheData == null) {
        // 直接访问数据库
        Object dbData = mapper.selectById(id);
        
        // 若数据库查询结果不为空，则放入缓存
        if (dbData != null) {
            redisTemplate.opsForValue().set(id, dbData, 30, TimeUnit.MINUTES);
        }
        
        return dbData;
    }
    
    return cacheData;
}
                        </code></pre>
                    </div>
                    <p>上述代码存在的问题是：如果大量请求查询不存在的数据（id不存在），缓存中没有，数据库中也没有，每次请求都会直接访问数据库，导致数据库压力剧增。</p>
                    
                    <h3>1.2 解决方案</h3>
                    <p><strong>1) 缓存空对象</strong></p>
                    <p>当数据库查询结果为空时，我们可以在缓存中存入一个空对象，并设置一个较短的过期时间。这样，下次再查询这个不存在的数据时，就会从缓存中获取到这个空对象，避免了对数据库的查询。</p>
                    <div class="code-block">
                        <pre><code class="language-java">
public Object getDataById(String id) {
    // 从缓存中获取数据
    Object cacheData = redisTemplate.opsForValue().get(id);
    
    // 判断是否为空对象标记
    if (cacheData != null && cacheData.equals("__NULL__")) {
        return null;
    }
    
    // 缓存为空，查询数据库
    if (cacheData == null) {
        // 访问数据库
        Object dbData = mapper.selectById(id);
        
        // 若数据库查询结果不为空，则放入缓存
        if (dbData != null) {
            redisTemplate.opsForValue().set(id, dbData, 30, TimeUnit.MINUTES);
        } else {
            // 数据库也没有，缓存空对象，设置较短过期时间
            redisTemplate.opsForValue().set(id, "__NULL__", 5, TimeUnit.MINUTES);
        }
        
        return dbData;
    }
    
    return cacheData;
}
                        </code></pre>
                    </div>
                    
                    <p><strong>2) 布隆过滤器</strong></p>
                    <p>布隆过滤器是一个很长的二进制向量和一系列随机哈希函数，它可以用于检索一个元素是否在一个集合中。其特点是存在误判（可能会将不存在的元素判断为存在），但不会将存在的元素判断为不存在。</p>
                    <p>我们可以将所有可能查询的数据ID哈希到布隆过滤器中，当有新的查询请求时，先用布隆过滤器判断该ID是否存在：</p>
                    <div class="code-block">
                        <pre><code class="language-java">
public Object getDataWithBloomFilter(String id) {
    // 布隆过滤器判断是否可能存在
    if (!bloomFilter.mightContain(id)) {
        return null; // ID不可能存在，直接返回
    }
    
    // 从缓存获取
    Object cacheData = redisTemplate.opsForValue().get(id);
    if (cacheData != null) {
        return cacheData;
    }
    
    // 查询数据库
    Object dbData = mapper.selectById(id);
    if (dbData != null) {
        // 写入缓存
        redisTemplate.opsForValue().set(id, dbData, 30, TimeUnit.MINUTES);
        return dbData;
    }
    
    return null;
}
                        </code></pre>
                    </div>
                    
                    <h2>2. 缓存击穿</h2>
                    <h3>2.1 问题描述</h3>
                    <p>缓存击穿是指热点数据的key在某个时间点过期（失效），恰好在这个时间点有大量的请求访问这个key，导致所有请求都直接访问数据库，造成数据库压力剧增。</p>
                    
                    <h3>2.2 解决方案</h3>
                    <p><strong>1) 互斥锁</strong></p>
                    <p>在缓存失效后，通过互斥锁保证只有一个线程能够重建缓存，其他线程等待或返回旧值。</p>
                    <div class="code-block">
                        <pre><code class="language-java">
public Object getDataWithMutex(String id) {
    // 从缓存获取数据
    Object cacheData = redisTemplate.opsForValue().get(id);
    if (cacheData != null) {
        return cacheData;
    }
    
    // 缓存中没有，尝试获取锁
    String lockKey = "lock:" + id;
    boolean locked = redisTemplate.opsForValue().setIfAbsent(lockKey, "1", 10, TimeUnit.SECONDS);
    
    if (locked) {
        try {
            // 再次检查缓存，防止其他线程已经重建缓存
            cacheData = redisTemplate.opsForValue().get(id);
            if (cacheData != null) {
                return cacheData;
            }
            
            // 查询数据库
            Object dbData = mapper.selectById(id);
            if (dbData != null) {
                // 写入缓存，设置随机过期时间，避免同时过期
                int expireTime = 30 + new Random().nextInt(10);
                redisTemplate.opsForValue().set(id, dbData, expireTime, TimeUnit.MINUTES);
            }
            
            return dbData;
        } finally {
            // 释放锁
            redisTemplate.delete(lockKey);
        }
    } else {
        // 没有获得锁，等待一段时间后重试
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return getDataWithMutex(id); // 递归调用
    }
}
                        </code></pre>
                    </div>
                    
                    <p><strong>2) 永不过期策略</strong></p>
                    <p>对于某些热点数据，我们可以设置永不过期，而是通过后台线程定期更新缓存，或者在访问时异步更新。</p>
                    <div class="code-block">
                        <pre><code class="language-java">
// 初始化时后台启动定时任务，定期更新热点数据
@Scheduled(fixedRate = 1800000) // 每30分钟执行一次
public void refreshHotData() {
    List<String> hotKeys = getHotKeysList(); // 获取热点key列表
    for (String key : hotKeys) {
        try {
            Object dbData = mapper.selectById(key);
            if (dbData != null) {
                // 不设置过期时间，相当于永不过期
                redisTemplate.opsForValue().set(key, dbData);
            }
        } catch (Exception e) {
            log.error("刷新热点数据失败: " + key, e);
        }
    }
}
                        </code></pre>
                    </div>
                    
                    <h2>3. 缓存雪崩</h2>
                    <h3>3.1 问题描述</h3>
                    <p>缓存雪崩是指在某一时刻，大量缓存集中过期失效或Redis服务宕机，导致所有请求都直接落到数据库上，造成数据库压力骤增，甚至崩溃的情况。</p>
                    
                    <h3>3.2 解决方案</h3>
                    <p><strong>1) 过期时间随机化</strong></p>
                    <p>为缓存设置随机过期时间，避免大量缓存同时过期。</p>
                    <div class="code-block">
                        <pre><code class="language-java">
public void setDataToCache(String key, Object value) {
    // 基础过期时间30分钟，加上0-15分钟的随机时间
    int baseExpireTime = 30;
    int randomTime = new Random().nextInt(15);
    int expireTime = baseExpireTime + randomTime;
    
    redisTemplate.opsForValue().set(key, value, expireTime, TimeUnit.MINUTES);
}
                        </code></pre>
                    </div>
                    
                    <p><strong>2) 构建多级缓存</strong></p>
                    <p>通过本地缓存 + Redis缓存的多级缓存架构，降低Redis宕机对系统的影响。</p>
                    <div class="code-block">
                        <pre><code class="language-java">
@Service
public class MultiLevelCacheService {
    
    @Autowired
    private RedisTemplate redisTemplate;
    
    @Autowired
    private DataMapper mapper;
    
    // 本地缓存，使用Caffeine
    private LoadingCache<String, Object> localCache = Caffeine.newBuilder()
            .maximumSize(10000)
            .expireAfterWrite(5, TimeUnit.MINUTES)
            .build(key -> null); // 本地缓存未命中时返回null
    
    public Object getData(String id) {
        // 先查本地缓存
        Object localData = localCache.getIfPresent(id);
        if (localData != null) {
            return localData;
        }
        
        // 查Redis缓存
        Object redisData = redisTemplate.opsForValue().get(id);
        if (redisData != null) {
            // 更新本地缓存
            localCache.put(id, redisData);
            return redisData;
        }
        
        // 查数据库
        Object dbData = mapper.selectById(id);
        if (dbData != null) {
            // 更新Redis和本地缓存
            redisTemplate.opsForValue().set(id, dbData, 30 + new Random().nextInt(10), TimeUnit.MINUTES);
            localCache.put(id, dbData);
        }
        
        return dbData;
    }
}
                        </code></pre>
                    </div>
                    
                    <p><strong>3) 服务熔断和降级</strong></p>
                    <p>当检测到缓存服务不可用或响应慢时，暂时切断缓存访问，启用降级策略（如返回预设的默认值、旧值或空值）。</p>
                    <div class="code-block">
                        <pre><code class="language-java">
@HystrixCommand(fallbackMethod = "getDefaultData", 
                commandProperties = {
                    @HystrixProperty(name = "circuitBreaker.enabled", value = "true"),
                    @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold", value = "10"),
                    @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage", value = "50"),
                    @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds", value = "5000")
                })
public Object getDataWithHystrix(String id) {
    // 从缓存获取数据
    Object cacheData = redisTemplate.opsForValue().get(id);
    if (cacheData != null) {
        return cacheData;
    }
    
    // 查询数据库
    Object dbData = mapper.selectById(id);
    if (dbData != null) {
        // 异步更新缓存
        CompletableFuture.runAsync(() -> {
            redisTemplate.opsForValue().set(id, dbData, 30 + new Random().nextInt(10), TimeUnit.MINUTES);
        });
    }
    
    return dbData;
}

// 降级方法
public Object getDefaultData(String id) {
    log.warn("触发降级，返回默认值或本地缓存值");
    return localCache.getIfPresent(id); // 返回本地缓存或默认值
}
                        </code></pre>
                    </div>
                    
                    <h2>4. 实践总结</h2>
                    <p>在实际项目中，我们通常需要根据具体业务场景来选择合适的解决方案：</p>
                    <ol>
                        <li><strong>对于缓存穿透</strong>：一般来说，对于查询量大但命中率低的场景，优先考虑布隆过滤器；对于简单场景，缓存空对象也是一个简单有效的方案。</li>
                        <li><strong>对于缓存击穿</strong>：热点数据是重点防护对象，可以采用互斥锁方案；对于更新频率低的超热点数据，可以考虑永不过期策略。</li>
                        <li><strong>对于缓存雪崩</strong>：这是最危险的情况，建议综合使用过期时间随机化、多级缓存架构以及熔断降级等手段来进行防护。</li>
                    </ol>
                    <p>此外，还有一些通用的最佳实践：</p>
                    <ul>
                        <li>合理设置缓存容量和过期策略，避免缓存过大导致内存压力</li>
                        <li>监控缓存命中率，及时发现异常情况</li>
                        <li>重要数据双写（先写数据库，再删除/更新缓存）</li>
                        <li>使用Redis集群提高可用性</li>
                    </ul>
                    
                    <h2>总结</h2>
                    <p>缓存穿透、击穿和雪崩是使用Redis作为缓存中间件时常见的挑战，通过本文介绍的各种解决方案，我们可以构建一个更健壮、更高效的缓存系统。在实际应用中，往往需要结合多种方案来应对各类风险，确保系统的稳定性和高性能。</p>
                    <p>最后，记住缓存并非万能，在设计缓存策略时，需要权衡系统复杂度、内存使用、一致性要求等多方面因素，选择最适合当前业务场景的解决方案。</p>
                </div>
                
                <div class="post-footer">
                    <div class="post-share">
                        <span>分享到：</span>
                        <a href="#" target="_blank"><i class="fab fa-weixin"></i></a>
                        <a href="#" target="_blank"><i class="fab fa-weibo"></i></a>
                        <a href="#" target="_blank"><i class="fab fa-twitter"></i></a>
                    </div>
                    
                    <div class="post-tags">
                        <span>标签：</span>
                        <a href="../tech-blog.html" class="post-tag">Redis</a>
                        <a href="../tech-blog.html" class="post-tag">缓存</a>
                        <a href="../tech-blog.html" class="post-tag">高并发</a>
                    </div>
                </div>
            </article>
            
            <div class="post-navigation">
                <a href="#" class="prev-post">
                    <i class="fas fa-arrow-left"></i>
                    <span>上一篇：Java并发编程：从JUC到线程池的深入剖析</span>
                </a>
                <a href="#" class="next-post">
                    <span>下一篇：RAG系统在企业知识库中的实践与优化</span>
                    <i class="fas fa-arrow-right"></i>
                </a>
            </div>
            
            <div class="related-posts">
                <h3>相关推荐</h3>
                <div class="related-posts-grid">
                    <a href="#" class="related-post">
                        <div class="related-post-img">
                            <img src="../images/blog/redis-lock.jpg" alt="Redis分布式锁">
                        </div>
                        <h4>使用Redis实现高可靠的分布式锁</h4>
                    </a>
                    <a href="#" class="related-post">
                        <div class="related-post-img">
                            <img src="../images/blog/java-concurrency.jpg" alt="Java并发编程">
                        </div>
                        <h4>Java并发编程：从JUC到线程池的深入剖析</h4>
                    </a>
                    <a href="#" class="related-post">
                        <div class="related-post-img">
                            <img src="../images/blog/spring-boot.jpg" alt="Spring Boot">
                        </div>
                        <h4>Spring Boot 实现分布式系统的最佳实践</h4>
                    </a>
                </div>
            </div>
        </div>
    </main>

    <footer>
        <div class="container">
            <div class="footer-content">
                <p>&copy; 2023 YOUNG的个人博客. All Rights Reserved.</p>
                <div class="social-links">
                    <a href="#" target="_blank"><i class="fab fa-github"></i></a>
                    <a href="#" target="_blank"><i class="fab fa-linkedin"></i></a>
                    <a href="#" target="_blank"><i class="fab fa-weixin"></i></a>
                    <a href="#" target="_blank"><i class="fab fa-zhihu"></i></a>
                </div>
            </div>
        </div>
    </footer>

    <script src="../js/main.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // 代码高亮
            hljs.highlightAll();
            
            // 动态设置年份
            const year = new Date().getFullYear();
            const copyrightEl = document.querySelector('footer p');
            if (copyrightEl) {
                copyrightEl.textContent = copyrightEl.textContent.replace('2023', year);
            }
        });
    </script>
</body>
</html> 